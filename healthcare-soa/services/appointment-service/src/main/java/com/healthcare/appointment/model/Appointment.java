package com.healthcare.appointment.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import java.time.LocalDateTime;

/**
 * Entity representing the Appointment table.
 * 
 * In enterprise environments like banks or healthcare companies, database schemas
 * are often strictly controlled. This implementation is designed to work with the
 * existing schema constraints where the application user doesn't have schema modification
 * privileges.
 */
@Entity
@Table(name = "appointments")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Appointment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", columnDefinition = "serial")
    private Integer id;

    // ID getter/setters generated by Lombok @Data

    @NotNull(message = "Patient ID is required")
    @Column(name = "patient_id")
    private Long patientId;

    @NotBlank(message = "Appointment type is required")
    @Column(name = "appointment_type")
    private String appointmentType;

    /**
     * Store appointment date/time info in the patient_id field temporarily
     * until proper schema updates can be made through formal channels.
     * This is a common pattern in enterprises where database schema changes
     * require formal approval processes.
     */
    @Transient
    private LocalDateTime appointmentDateTime;
    
    @Column(name = "doctor_name")
    private String doctorName;
    
    /**
     * Department info is stored in notes field temporarily
     * until schema changes are approved
     */
    @Transient
    private String department;
    
    @Column(name = "notes")
    private String notes;
    
    /**
     * Custom getter that deserializes date from notes if needed
     */
    public LocalDateTime getAppointmentDateTime() {
        if (appointmentDateTime == null && notes != null && notes.startsWith("DATE:")) {
            try {
                String dateStr = notes.substring(5, notes.indexOf("|"));
                return LocalDateTime.parse(dateStr);
            } catch (Exception e) {
                // Graceful degradation if parsing fails
                return null;
            }
        }
        return appointmentDateTime;
    }
    
    /**
     * Custom setter that serializes date into notes field
     */
    public void setAppointmentDateTime(LocalDateTime dateTime) {
        this.appointmentDateTime = dateTime;
        // Store in notes field as workaround for schema limitations
        String deptStr = (department != null) ? department : "";
        if (dateTime != null) {
            this.notes = "DATE:" + dateTime.toString() + "|DEPT:" + deptStr + "|" + 
                      (notes != null ? notes.replaceAll("DATE:.*?\\|", "").replaceAll("DEPT:.*?\\|", "") : "");
        }
    }
    
    /**
     * Custom getter that deserializes department from notes if needed
     */
    public String getDepartment() {
        if (department == null && notes != null && notes.contains("DEPT:")) {
            try {
                String deptSection = notes.substring(notes.indexOf("DEPT:") + 5);
                return deptSection.substring(0, deptSection.indexOf("|"));
            } catch (Exception e) {
                // Graceful degradation
                return null;
            }
        }
        return department;
    }
    
    /**
     * Custom setter that serializes department into notes field
     */
    public void setDepartment(String dept) {
        this.department = dept;
        // Preserve any existing date in notes
        if (notes == null) notes = "";
        String dateStr = ""; 
        if (appointmentDateTime != null) {
            dateStr = "DATE:" + appointmentDateTime.toString() + "|";
        } else if (notes.contains("DATE:")) {
            dateStr = notes.substring(notes.indexOf("DATE:"), notes.indexOf("|") + 1);
        }
        
        if (dept != null) {
            this.notes = dateStr + "DEPT:" + dept + "|" + 
                    (notes != null ? notes.replaceAll("DATE:.*?\\|", "").replaceAll("DEPT:.*?\\|", "") : "");
        }
    }

    @Column(name = "status")
    @Enumerated(EnumType.STRING)
    private AppointmentStatus status = AppointmentStatus.SCHEDULED;
}
